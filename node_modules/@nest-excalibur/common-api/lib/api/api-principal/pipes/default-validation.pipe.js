"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultValidationPipe = void 0;
const common_1 = require("@nestjs/common");
const class_transformer_1 = require("class-transformer");
const class_validator_1 = require("class-validator");
const logger_service_1 = require("../services/logger.service");
class DefaultValidationPipe {
    constructor(dto, showErrors = true, validateId) {
        this.dto = dto;
        this.showErrors = showErrors;
        this.validateId = validateId;
    }
    transform(value, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.dto || !this.toValidate(this.dto)) {
                return value;
            }
            const entityDto = class_transformer_1.plainToClass(this.dto, value);
            const validationErrors = yield class_validator_1.validate(entityDto);
            const logger = logger_service_1.LoggerService.getInstance().logger;
            if (validationErrors.length > 0) {
                logger.error(validationErrors, 'DefaultValidationPipe');
                const message = this.validateId ? 'Invalid id' : 'Invalid payload';
                const errorMessage = {
                    message,
                    errors: validationErrors,
                };
                if (!this.showErrors)
                    delete errorMessage.errors;
                throw new common_1.BadRequestException(errorMessage);
            }
            return value;
        });
    }
    toValidate(metatype) {
        const types = [String, Boolean, Number, Array, Object];
        return !types.includes(metatype);
    }
}
exports.DefaultValidationPipe = DefaultValidationPipe;
