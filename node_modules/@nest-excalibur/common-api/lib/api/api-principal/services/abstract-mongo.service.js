"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractMongoService = void 0;
const principal_service_1 = require("./principal.service");
const crud_exception_filter_1 = require("../exceptions/crud-exception.filter");
const logger_service_1 = require("./logger.service");
class AbstractMongoService extends principal_service_1.PrincipalService {
    constructor(mongoRepository, indexConfig) {
        super(mongoRepository);
        this.mongoRepository = mongoRepository;
        this.indexConfig = indexConfig;
        const logger = logger_service_1.LoggerService.getInstance().logger;
        if (indexConfig) {
            const className = this.constructor.name;
            this
                .createIndex(indexConfig)
                .then(index => logger.verbose(`Index created: ${index}`, className)).catch((createIndxException) => {
                const { error, data } = createIndxException.errorPayload;
                logger.error(`Error on create index on: ${className}`, data, error);
            });
        }
    }
    createOne(row) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return this.mongoRepository.save(row);
            }
            catch (error) {
                throw new crud_exception_filter_1.CreateOneException({
                    error,
                    message: 'Error on delete document',
                    data: {
                        document: row,
                    },
                });
            }
        });
    }
    deleteOne(id) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const ObjectId = require('mongodb').ObjectID;
                return (yield this.mongoRepository.findOneAndDelete({
                    _id: ObjectId(id),
                })).value;
            }
            catch (error) {
                throw new crud_exception_filter_1.DeleteOneException({
                    error,
                    message: 'Error on delete document',
                    data: {
                        id,
                    },
                });
            }
        });
    }
    findAll(optionsOrConditions) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (optionsOrConditions) {
                    return yield this.mongoRepository.findAndCount(optionsOrConditions);
                }
                else {
                    return yield this.mongoRepository.findAndCount({ skip: 0, take: 10 });
                }
            }
            catch (error) {
                throw new crud_exception_filter_1.FindAllException({
                    error,
                    message: 'Error on fetch documents',
                    data: {
                        query: optionsOrConditions,
                    },
                });
            }
        });
    }
    findOneById(id) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.mongoRepository.findOneOrFail(id);
            }
            catch (error) {
                throw new crud_exception_filter_1.FindOneByIdException({
                    error,
                    message: 'Record Not found',
                    data: {
                        id,
                    },
                });
            }
        });
    }
    updateOne(id, row) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const ObjectId = require('mongodb').ObjectID;
                const updateResponse = yield this.mongoRepository.updateOne({
                    _id: ObjectId(id),
                }, { $set: Object.assign({}, row) }, { upsert: false, });
                return yield this.mongoRepository.findOne(id);
            }
            catch (error) {
                throw new crud_exception_filter_1.UpdateOneException({
                    error,
                    message: 'Error on update',
                    data: {
                        id,
                        document: row,
                    },
                });
            }
        });
    }
    createMany(documents) {
        return __awaiter(this, void 0, void 0, function* () {
            let createdDocuments;
            let ids = [];
            try {
                createdDocuments = yield this.mongoRepository.insertMany(documents);
            }
            catch (error) {
                throw new crud_exception_filter_1.CreateManyException({
                    error,
                    message: 'Error on create many documents',
                    data: {
                        documents,
                    },
                });
            }
            try {
                ids = createdDocuments.insertedIds;
                const query = {
                    where: {
                        _id: {
                            $in: [ids],
                        },
                    },
                };
                return (yield this.findAll(query))[0];
            }
            catch (error) {
                throw new crud_exception_filter_1.FindAllException({
                    error,
                    message: 'Error on fecth the created documents',
                    data: {
                        created: documents,
                    },
                });
            }
        });
    }
    updateMany(documents) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.mongoRepository.save(documents);
            }
            catch (error) {
                throw new crud_exception_filter_1.UpdateManyException({
                    error,
                    message: 'Error on updated many documents',
                    data: {
                        documents,
                    }
                });
            }
        });
    }
    deleteMany(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            const ObjectId = require('mongodb').ObjectID;
            const formatIds = ids.map(id => ObjectId(id));
            try {
                const deleteResponse = yield this.mongoRepository.deleteMany({
                    where: {
                        _id: { $in: [...formatIds] },
                    },
                });
                return deleteResponse.deletedCount ? deleteResponse.deletedCount : 0;
            }
            catch (error) {
                throw new crud_exception_filter_1.DeleteManyException({
                    error,
                    message: 'Error on delte many documents',
                    data: {
                        ids,
                    },
                });
            }
        });
    }
    createIndex(config) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.mongoRepository
                    .createCollectionIndex(config.fieldOrSpec, config.options);
            }
            catch (error) {
                throw new crud_exception_filter_1.CreateIndexException({
                    error,
                    message: 'maybe the index already exist',
                    data: {
                        config,
                    },
                });
            }
        });
    }
}
exports.AbstractMongoService = AbstractMongoService;
