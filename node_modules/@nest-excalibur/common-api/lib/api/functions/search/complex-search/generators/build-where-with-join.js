"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildWhereWithjoin = void 0;
const split_query_attributes_by_type_1 = require("../splitters/split-query-attributes-by-type");
const find_join_relation_type_1 = require("../splitters/find-join-relation-type");
const build_simple_pure_where_1 = require("./build-simple-pure-where");
const build_pure_where_with_operator_1 = require("./build-pure-where-with-operator");
const build_pure_or_where_1 = require("./build-pure-or-where");
const verificator_helper_1 = require("../verificators-functions/verificator-helper");
const build_select_1 = require("./build-select");
function buildWhereWithjoin(currentSelectQuieryBuilder, attributeName, attributeValue, parentEntity, joinType = 'inner') {
    // Si la relacion tiene condiciones EJ: "producto": {"habilitado": 1, "id": {"operacion":"In", "valores": [1,2,3]}}
    const objectIsNotEmpty = verificator_helper_1.VerificatorHelper.verifyIsNotEmptyObject(attributeValue);
    const relation = `${parentEntity}.${attributeName}`;
    const alias = attributeName;
    let conditions = [];
    if (objectIsNotEmpty) {
        // separar simples de compuestos
        const attributesSimplesAndComplexObject = split_query_attributes_by_type_1.splitQueryAttributesByType(attributeValue);
        const subQueryObject = attributeValue;
        // Armamos el select
        const selectAttrs = attributesSimplesAndComplexObject.selectAttrs;
        // Armamos las condiciones
        const simpleQueryConditions = attributesSimplesAndComplexObject.simpleQueries.reduce((acumulator, subAttribute) => {
            const generatedPureWhere = build_simple_pure_where_1.buildSimplePureWhere(subAttribute, subQueryObject[subAttribute], attributeName);
            if (generatedPureWhere) {
                acumulator.push(generatedPureWhere);
            }
            return acumulator;
        }, []);
        const complexOperatorQueryConditions = attributesSimplesAndComplexObject.complexOperatorsQueries.reduce((acumulator, subAttribute) => {
            const generatedPureWhereWithOperator = build_pure_where_with_operator_1.buildPureWhereWithOperator(subAttribute, subQueryObject[subAttribute], attributeName);
            if (generatedPureWhereWithOperator) {
                acumulator.push(generatedPureWhereWithOperator);
            }
            return acumulator;
        }, []);
        const whereOrConditions = attributesSimplesAndComplexObject.whereOrQueries.reduce((acumulator, subAatributo) => {
            const pureWhereOrGenerated = build_pure_or_where_1.buildPureOrWhere(subAatributo, subQueryObject[subAatributo], attributeName);
            if (pureWhereOrGenerated) {
                acumulator.push(pureWhereOrGenerated);
            }
            return acumulator;
        }, []);
        // Todas las condiciones se las agrega a un arreglo de condiciones
        conditions = [...simpleQueryConditions, ...complexOperatorQueryConditions, ...whereOrConditions];
        // Establecemos el objeto de tipo relacionPurta este objeto sera el acumulador inicial
        const basePureRelation = {
            relation,
            alias,
            condition: '',
            parameters: {},
        };
        // generaremos un nuevo objeto de tipo relacion pura en base al acumlador inicial
        const pureJoinRelation = conditions.reduce((acumulator, condition, index) => {
            // juntar los where con las conjunciones
            if (index > 0) {
                acumulator.condition = acumulator.condition + ' ' + condition.conjunction + ' ' + condition.where;
            }
            else {
                acumulator.condition = acumulator.condition + ' ' + condition.where;
            }
            // juntar los parametros
            acumulator.parameters = Object.assign(Object.assign({}, acumulator.parameters), condition.parameters);
            return acumulator;
        }, basePureRelation);
        if (joinType === 'inner') {
            if ((selectAttrs === null || selectAttrs === void 0 ? void 0 : selectAttrs.length) && selectAttrs.length > 0) {
                currentSelectQuieryBuilder = currentSelectQuieryBuilder.innerJoin(basePureRelation.relation, basePureRelation.alias, basePureRelation.condition, pureJoinRelation.parameters);
                currentSelectQuieryBuilder = build_select_1.buildSelect(currentSelectQuieryBuilder, attributeName, selectAttrs);
            }
            else {
                currentSelectQuieryBuilder = currentSelectQuieryBuilder.innerJoinAndSelect(basePureRelation.relation, basePureRelation.alias, basePureRelation.condition, pureJoinRelation.parameters);
            }
        }
        else {
            if ((selectAttrs === null || selectAttrs === void 0 ? void 0 : selectAttrs.length) && selectAttrs.length > 0) {
                currentSelectQuieryBuilder = currentSelectQuieryBuilder.leftJoin(basePureRelation.relation, basePureRelation.alias, basePureRelation.condition, pureJoinRelation.parameters);
                currentSelectQuieryBuilder = build_select_1.buildSelect(currentSelectQuieryBuilder, attributeName, selectAttrs);
            }
            else {
                currentSelectQuieryBuilder = currentSelectQuieryBuilder.leftJoinAndSelect(basePureRelation.relation, basePureRelation.alias, basePureRelation.condition, pureJoinRelation.parameters);
            }
        }
        // En caso de que tambien la relacion tuviera otras relaciones anidades se volvera a llamar a esta funcion
        // para los compuestos es recursivo,
        attributesSimplesAndComplexObject.complexQueries.forEach((subattribute) => {
            const joinRelationType = find_join_relation_type_1.findJoinRelationType(subQueryObject[subattribute]);
            currentSelectQuieryBuilder = buildWhereWithjoin(currentSelectQuieryBuilder, subattribute, subQueryObject[subattribute], attributeName, joinRelationType);
        });
    }
    else {
        if (joinType === 'inner') {
            currentSelectQuieryBuilder = currentSelectQuieryBuilder.innerJoinAndSelect(`${parentEntity}.${attributeName}`, `${attributeName}`);
        }
        else {
            currentSelectQuieryBuilder = currentSelectQuieryBuilder.leftJoinAndSelect(`${parentEntity}.${attributeName}`, `${attributeName}`);
        }
    }
    return currentSelectQuieryBuilder;
}
exports.buildWhereWithjoin = buildWhereWithjoin;
